/**
 *
 * Copyright 2022 by Guangzhou Easy EAI Technologny Co.,Ltd.
 * website: www.easy-eai.com
 *
 * Author: ZJH <zhongjiehao@easy-eai.com>
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * License file for more details.
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>

#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <netinet/if_ether.h>
#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>

#include "network.h"
#include <arpa/inet.h>

#include <string>
#include <iostream>
#include <fstream>
#include <sstream>

//using namespace std;
/*********************************************************************
Function: 
Description:
    获取网络数据流量统计信息
Example:
    int64_t recvByte, sendByte;
    int32_t ret = get_dataflow_statistics("eth0", &recvByte, &snedByte);
parameter:
    *device  : 网卡
    *total_recv : 累计已接收(下行)的数据量，单位：字节(Byte)
    *total_send : 累计已发送(上行)的数据量，单位：字节(Byte)
Return:
    成功：0
    失败：-1 
********************************************************************/
int32_t get_dataflow_statistics(const char *device, int64_t *total_recv, int64_t *total_send) 
{
     if((NULL == device)||(NULL == total_recv)||(NULL == total_send)) {
        printf("bad param\n");
        return -1;    
    }
    
    FILE *netdev_Fp = NULL;
    netdev_Fp = fopen("/proc/net/dev", "r");
    if (NULL == netdev_Fp) {
        printf("open file /proc/net/dev/ error!\n");
        return -1;
    }
    
    int counter = 0;
    char *match = NULL;    //用以保存所匹配字符串及之后的内容
    char buffer[1024];  //文件中的内容暂存在字符缓冲区里
    char tmp_value[128];
    
    memset(buffer, 0, sizeof(buffer));
    while(NULL != fgets(buffer, sizeof(buffer), netdev_Fp))
    {
        match = strstr(buffer, device);
        if(NULL == match) {
            //printf("no eth0 keyword to find!\n");
            continue;
        } else {
            //printf("%s\n",buffer);
            match = match + strlen(device) + strlen(":");/*地址偏移到冒号*/
            sscanf(match, "%lld ", total_recv);
            memset(tmp_value, 0, sizeof(tmp_value));
            sscanf(match, "%s ", tmp_value);
            match = match + strlen(tmp_value);
            for(size_t i = 0; i < strlen(buffer); i++)
            {
                if(0x20 == *match) {
                    match++;
                } else {
                    if(8 == counter) {
                        sscanf(match,"%lld ", total_send);
                    }
                    memset(tmp_value,0,sizeof(tmp_value));
                    sscanf(match,"%s ",tmp_value);
                    match = match + strlen(tmp_value);
                    counter++;
                }
            }
            //printf("%s save_rate:%ld tx_rate:%ld\n",netname,*save_rate,*tx_rate);
        }
    }
    fclose(netdev_Fp);
    return 0;
}

/*********************************************************************
Function:
Description:
    设置：ip地址、子网掩码、网关
Example:
    int ret = set_net_ipv4("eth0","192.168.1.151", "255.255.255.0", "192.168.1.1");
parameter:
    *device  : 网卡
    *ip      : 点分十进制的IP地址
    *mask    : 点分十进制的子网掩码
    *gateway : 点分十进制的网关
Return:
	重启网络脚本的执行结果
********************************************************************/
int32_t set_net_ipv4(const char *device, const char *ip, const char *mask, const char *gateway)
{
	if(0 == strlen(device))
		return -1;
	
	if( address_invaild(ip)||address_invaild(mask) )
		return -1;
	
	/*判断IP与网关是否处于同一网段*/
	bool bIsSetGateway = true;
	if(address_invaild(gateway)){
		bIsSetGateway = false;
	}else{
		uint8_t binIP[4], binMask[4], binGateWay[4];
		ipv4_str_to_bin((char *)ip, (char *)binIP);
		ipv4_str_to_bin((char *)mask, (char *)binMask);
		ipv4_str_to_bin((char *)gateway, (char *)binGateWay);
		uint8_t netIP, netGW;
		for(int i = 0; i < 4; i++){
			netIP = binMask[i] & binIP[i];
			netGW = binMask[i] & binGateWay[i];
			if(netIP != netGW){
				bIsSetGateway = false;
				break;
			}
		}
	}
	
    if(0 == strcmp(device, "eth0")){
        const char *FILE_NAME = "/etc/network/interfaces";

        std::string strAddress   = "    address ";
        std::string strNetmask   = "    netmask ";
        std::string strGateway   = "    gateway ";
    //    std::string strBroadcast = "    broadcast "; 

        strAddress.append(ip);
        strAddress.append("\n");
        strNetmask.append(mask);
        strNetmask.append("\n");
        strGateway.append(gateway);
        strGateway.append("\n");
    //    strBroadcast.append(broadcast);
    //    strBroadcast.append("\n");

        std::ofstream ofs(FILE_NAME, std::ios::binary);
        ofs << "# interface file auto-generated by buildroot\n";
        ofs << "\n";
        ofs << "auto lo\n";
        ofs << "iface lo inet loopback\n";
        ofs << "auto eth0\n";
        ofs << "iface eth0 inet static\n";
        ofs << strAddress.c_str();
        ofs << strNetmask.c_str();
		if(bIsSetGateway){ ofs << strGateway.c_str(); }
    //    ofs << strBroadcast.c_str();
        ofs.close();

        return system("/etc/init.d/S40network restart");
    }else if(0 == strcmp(device, "usb0")){
        return -1;
    }else{
		return -1;
	}
}

/*********************************************************************
Function:
Description:
    读取 MAC 地址
Example:
	#define MAX_MAC_LEN 8
    char mac[MAX_MAC_LEN];
    if(0 == get_local_Mac("eth0", mac, MAX_MAC_LEN)) {
		printf("get mac succ\n");
	}
parameter:
    *device : 网卡
    *mac    : 用于存放读出来的mac地址
    ip_len  : 用于存放mac地址的缓存长度
Return:
	-1：失败
	0 ：成功
********************************************************************/
int32_t get_local_Mac(const char *device, char *mac, int mac_len)
{
	int sockfd;
    struct ifreq req;

    memset(mac, 0, mac_len);
    if (-1 == (sockfd = socket(PF_INET, SOCK_DGRAM, 0)))
    {
        fprintf(stderr,"Sock Error: %s \n\a", strerror(errno));
        return -1;
    }

    bzero(&req, sizeof(req));
    strncpy(req.ifr_name, device, sizeof(req.ifr_name));

    if (-1 == ioctl(sockfd, SIOCGIFHWADDR, (char *)&req))
    {
        fprintf ( stderr,"ioctl SIOCGIFHWADDR:%s\n\a",strerror ( errno ) );
        close(sockfd);
        return -1;
    }
    
    memcpy(mac, req.ifr_hwaddr.sa_data, 6);

    return 0;
}

/*********************************************************************
Function:
Description:
    读取IP地址
Example:
	#define MAX_IP_LEN 20
    char ip[MAX_IP_LEN];
    if(0 == get_local_Ip("eth0", ip, MAX_IP_LEN)) {
		printf("get ip succ\n");
	}
parameter:
    *device : 网卡
    *ip     : 用于存放读出来的ip地址
    ip_len  : 用于存放ip地址的缓存长度
Return:
	-1：失败
	0 ：成功
********************************************************************/
int32_t get_local_Ip(const char *device, char *ip, int ip_len)
{
    int sd;
    struct sockaddr_in sin;
    struct ifreq ifr;

    memset(ip, 0, ip_len);
    sd = socket(AF_INET, SOCK_DGRAM, 0);
    if (-1 == sd) {
        printf("socket error: %s\n", strerror(errno));
        return -1;
    }

    strncpy(ifr.ifr_name, device, IFNAMSIZ);
    ifr.ifr_name[IFNAMSIZ - 1] = 0;

    if (ioctl(sd, SIOCGIFADDR, &ifr) < 0) {
        printf("ioctl error: %s\n", strerror(errno));
        close(sd);
        return -1;
    }

    memcpy(&sin, &ifr.ifr_addr, sizeof(sin));
    sprintf(ip, "%s", inet_ntoa(sin.sin_addr));

    close(sd);
    return 0;
}

/*********************************************************************
Function:
Description:
    读取子网掩码
Example:
	#define MAX_MASK_LEN 20
    char netMask[MAX_MASK_LEN];
    if(0 == get_local_NetMask("eth0", netMask, MAX_MASK_LEN)) {
		printf("get netMask succ\n");
	}
parameter:
    *device     : 网卡
    *netMask    : 用于存放读出来的子网掩码
    netMask_len : 用于存放子网掩码的缓存长度
Return:
	-1：失败
	0 ：成功
********************************************************************/
int32_t get_local_NetMask(const char *device, char *netMask, int netMask_len)
{ 
    int sd;
    struct sockaddr_in sin;
    struct ifreq ifr;
	
    memset(netMask, 0, netMask_len);
    sd = socket(AF_INET, SOCK_DGRAM, 0);
    if (-1 == sd) {
        printf("socket error: %s\n", strerror(errno));
        return -1;
    }
    
    ifr.ifr_addr.sa_family = AF_INET;
    
    strncpy(ifr.ifr_name, device, IFNAMSIZ);
    ifr.ifr_name[IFNAMSIZ - 1] = 0;

    if (ioctl(sd, SIOCGIFNETMASK, &ifr) < 0) {
        printf("ioctl error: %s\n", strerror(errno));
        close(sd);
        return -1;
    }

    memcpy(&sin, &ifr.ifr_addr, sizeof(sin));
    sprintf(netMask, "%s", inet_ntoa(sin.sin_addr));

    close(sd);
	return 0;
}

/*********************************************************************
Function:
Description:
    读取默认网关
Example:
	#define MAX_GW_LEN 20
    char gateWay[MAX_GW_LEN];
    if(0 == get_local_GateWay("eth0", gateWay, MAX_GW_LEN)) {
		printf("get gateWay succ\n");
	}
parameter:
    *device     : 网卡
    *gateWay    : 用于存放读出来的默认网关
    gateWay_len : 用于存放默认网关的缓存长度
Return:
	-1：失败
	0 ：成功
********************************************************************/
int32_t get_local_GateWay(const char *device, char *gateWay, int gateWay_len)
{
    memset(gateWay, 0, gateWay_len);
	
	char cmd[128] = {0};
    memset(cmd, 0, sizeof(cmd));
    sprintf(cmd,"route -n|grep %s|grep 0.0.0.0|awk \'NR==1 {print $2}\'", device);
    FILE* fp = popen( cmd, "r" );
    if(NULL == fp) {
        printf("popen error: %s\n", strerror(errno));
        return -1;
    }
    
	while ( NULL != fgets(gateWay, gateWay_len, fp)) {
        if(gateWay[strlen(gateWay)-1] == '\n') {
           gateWay[strlen(gateWay)-1] = 0;
        }
        break;
    }
    pclose(fp);
	return 0;
}

/*********************************************************************
Function:
Description:
	把字符串形式的IP地址转换为数字形式
Example:
	char *strIP = "192.168.1.233";
	char ipAddr[4] = {0};
	if(ipv4_str_to_bin(strIP, ipAddr)){
		printf("[ipAddr] = %02x:%02x:%02x:%02x\n", ipAddr[0], ipAddr[1], ipAddr[2], ipAddr[3]);
	}
parameter:
    *strIP : 输入的 ip地址字符串
    *binIP : 输出的 ip地址数组
Return:
	true 成功 false 失败
********************************************************************/
bool ipv4_str_to_bin(const char *strIP, char *binIP)
{
    int i;
    char *s, *e;

    if ((binIP == NULL) || (strIP == NULL))
    {
        return false;
    }

    s = (char *) strIP;
    for (i = 0; i < 4; ++i)
    {
        binIP[i] = s ? strtoul(s, &e, 10) : 0;
        if (s)
           s = (*e) ? e + 1 : e;
    }
    return true;
}

/*********************************************************************
Function:
Description:
	把字符串形式的mac地址转换为数字形式
Example:
	char *strMac = "BC:8D:0A:7F:85:5E";
	char mac[6] = {0};
	if(mac_str_to_bin(strMac, mac)){
		printf("[mac] = %02x:%02x:%02x:%02x:%02x:%02x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
	}
parameter:
    *strMac : 输入的mac地址字符串
    *binMac : 输出的mac地址数组
Return:
	true 成功 false 失败
********************************************************************/
bool mac_str_to_bin(const char *strMac, char *binMac)
{
    int i;
    char *s, *e;

    if ((binMac == NULL) || (strMac == NULL))
    {
        return false;
    }

    s = (char *) strMac;
    for (i = 0; i < 6; ++i)
    {
        binMac[i] = s ? strtoul(s, &e, 16) : 0;
        if (s)
           s = (*e) ? e + 1 : e;
    }
    return true;
}

/*********************************************************************
Function:
Description:
	判断IP地址是否遵循点分十进制
Example:
	if(!address_invaild("192.168.001.110"){
		printf("ip is vaild\n");
	}else{
		printf("ip is invaild\n");		
	}
parameter:
    *addr : 待判定的Ipv4地址
Return:
	true 无效的地址
	false 有效的地址
********************************************************************/
bool address_invaild(const char *addr_IPv4)
{
	int8_t pointNum = 0;
	for(uint32_t i = 0; i < strlen(addr_IPv4); i++){
		if('.' == addr_IPv4[i]){
			pointNum++;
		}
	}
	
	if(3 != pointNum)
		return true;
	
#if 0 //这段没啥用，遇到非数字就会分割。超出255就会取余
	uint8_t ip[4];
	ipv4_str_to_bin((char *)addr_IPv4, (char *)ip);
	for(uint32_t i = 0; i < sizeof(ip); i++){
		if((ip[i] <= 0) || (ip[i] >= 255))
			return true;
	}
#endif
	
	return false;
}

/*********************************************************************
Function:
Description:
	比较为域名形式或为点分十进制的字符串形式的IP地址，
	忽略点分十进制前面或中间无效的0
Example:
	if(compare_IpAddr("192.168.001.110", "192.168.01.110")){
		printf("ip is sam\n");
	}else{
		printf("ip is not  sam\n");		
	}
parameter:
    *addr1 : 待比对Ip地址
    *addr2 : 待比对Ip地址
Return:
	true 相同 false 不同
********************************************************************/
bool compare_IpAddr(char *addr1, char *addr2)
{
	char tmpAddr1[64] = ".";
	char tmpAddr2[64] = ".";
	uint32_t i = 0, j = 0;
	bool ret = false;

	if ((addr1[0] < '0' || addr1[0] > '9') || (addr2[0] < '0' || addr2[0] > '9'))
	{
		if (0 == strcmp(addr1, addr2))
		{
			ret = true;
		}
	}
	else
	{
		for (j = 0, i = 0; i < strlen(addr1) + 1; i++)
		{
			if (addr1[i] == '0' && tmpAddr1[j] == '.')
				continue;
			tmpAddr1[++j] = addr1[i];
		}
		
		for (j = 0, i = 0; i < strlen(addr2) + 1; i++)
		{
			if (addr2[i] == '0' && tmpAddr2[j] == '.')
				continue;
			tmpAddr2[++j] = addr2[i];
		}
		
		if (0 == strcmp(tmpAddr1, tmpAddr2))
		{
			ret = true;
		}
	}
	
	return ret;
}

char* netAddrToStr(uint64_t netAddr)
{
	struct sockaddr_in addr = {0};
	addr.sin_addr.s_addr = netAddr;
	char *str;
	str = inet_ntoa(addr.sin_addr);
	return str;
}

uint64_t strToNetAddr(const char *p_str)
{
	char str[36] = {0};
	strncpy(str, p_str, 36);
	struct in_addr addr = {0};
	if(inet_pton(AF_INET, str, (void *)&addr) != 1)
	{
		printf("fun:%s, line:%d, failed!\n", __FUNCTION__, __LINE__);
		return 0;
	}
	return addr.s_addr;
}

