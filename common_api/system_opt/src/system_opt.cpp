 /**
 *
 * Copyright 2021 by Guangzhou Easy EAI Technologny Co.,Ltd.
 * website: www.easy-eai.com
 *
 * Author: Jiehao.Zhong <zhongjiehao@easy-eai.com>
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * License file for more details.
 * 
 */

//===========================================system===========================================
#include <sys/time.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>

#include <netinet/if_ether.h>
#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <unistd.h>

#include <termios.h>
#include <pthread.h>
#include <assert.h>
#include <errno.h>
#include <ctype.h>
#include <netdb.h>
#include <iconv.h>
#include <fcntl.h>
#include <dirent.h>
#include <dirent.h>
#include <semaphore.h>

//=========================================== C++ ===========================================
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

//======================================= system_opt =======================================
#include "system_opt.h"

using namespace std;

/***********************************************************
    系统中有些地方需要对指针进行赋值，但在赋值之前需要
    判断指针是否为空，这里统一定义一个宏定义
************************************************************/
#define TRY_EVALUATE_POINTER(pointer, value) do{\
    if(pointer)\
    {\
        *(pointer) = value;\
    }\
}while(0)

/*********************************************************************
Function:
Description:
    设置：ip地址、子网掩码、网关
Example:
    int ret = set_net_ipv4("192.168.1.151", "255.255.255.0", "192.168.1.1");
parameter:
    *ip      : 点分十进制的IP地址
    *mask    : 点分十进制的子网掩码
    *gateway : 点分十进制的网关
Return:
	重启网络脚本的执行结果
********************************************************************/
int set_net_ipv4(const char *ip, const char *mask, const char *gateway)
{
    const char *FILE_NAME = "/etc/network/interfaces";

    std::string strAddress   = "    address ";
    std::string strNetmask   = "    netmask ";
    std::string strGateway   = "    gateway ";
//    std::string strBroadcast = "    broadcast ";

    strAddress.append(ip);
    strAddress.append("\n");
    strNetmask.append(mask);
    strNetmask.append("\n");
    strGateway.append(gateway);
    strGateway.append("\n");
//    strBroadcast.append(broadcast);
//    strBroadcast.append("\n");

    ofstream ofs(FILE_NAME, std::ios::binary);
    ofs << "# interface file auto-generated by buildroot\n";
    ofs << "\n";
    ofs << "auto lo\n";
    ofs << "iface lo inet loopback\n";
    ofs << "auto eth0\n";
    ofs << "iface eth0 inet static\n";
    ofs << strAddress.c_str();
    ofs << strNetmask.c_str();
    ofs << strGateway.c_str();
//    ofs << strBroadcast.c_str();
    ofs.close();

    return system("/etc/init.d/S40network restart");
}

/*********************************************************************
Function:
Description:
    读取IP地址
Example:
	#define MAX_IP_LEN 20
    char ip[MAX_IP_LEN];
    if(0 == get_local_Ip("eth0", ip, MAX_IP_LEN)) {
		printf("get ip succ\n");
	}
parameter:
    *device : 网卡
    *ip     : 用于存放读出来的ip地址
    ip_len  : 用于存放ip地址的缓存长度
Return:
	-1：失败
	0 ：成功
********************************************************************/
int get_local_Ip(const char *device, char *ip, int ip_len)
{
    int sd;
    struct sockaddr_in sin;
    struct ifreq ifr;

    memset(ip, 0, ip_len);
    sd = socket(AF_INET, SOCK_DGRAM, 0);
    if (-1 == sd) {
        printf("socket error: %s\n", strerror(errno));
        return -1;
    }

    strncpy(ifr.ifr_name, device, IFNAMSIZ);
    ifr.ifr_name[IFNAMSIZ - 1] = 0;

    if (ioctl(sd, SIOCGIFADDR, &ifr) < 0) {
        printf("ioctl error: %s\n", strerror(errno));
        close(sd);
        return -1;
    }

    memcpy(&sin, &ifr.ifr_addr, sizeof(sin));
    sprintf(ip, "%s", inet_ntoa(sin.sin_addr));

    close(sd);
    return 0;
}

/*********************************************************************
Function:
Description:
    读取 MAC 地址
Example:
	#define MAX_MAC_LEN 8
    char mac[MAX_MAC_LEN];
    if(0 == get_local_Mac("eth0", mac, MAX_MAC_LEN)) {
		printf("get mac succ\n");
	}
parameter:
    *device : 网卡
    *mac    : 用于存放读出来的mac地址
    ip_len  : 用于存放mac地址的缓存长度
Return:
	-1：失败
	0 ：成功
********************************************************************/
int get_local_Mac(const char *device, char *mac, int mac_len)
{
	int sockfd;
    struct ifreq req;

    memset(mac, 0, mac_len);
    if (-1 == (sockfd = socket(PF_INET, SOCK_DGRAM, 0)))
    {
        fprintf(stderr,"Sock Error: %s \n\a", strerror(errno));
        return -1;
    }

    bzero(&req, sizeof(req));
    strncpy(req.ifr_name, device, sizeof(req.ifr_name));

    if (-1 == ioctl(sockfd, SIOCGIFHWADDR, (char *)&req))
    {
        fprintf ( stderr,"ioctl SIOCGIFHWADDR:%s\n\a",strerror ( errno ) );
        close(sockfd);
        return -1;
    }
    
    memcpy(mac, req.ifr_hwaddr.sa_data, 6);

    return 0;
}

/*********************************************************************
Function:
Description:
	把字符串形式的mac地址转换为数字形式
Example:
	char *strIP = "192.168.1.233";
	char ipAddr[4] = {0};
	if(ipv4_str_to_bin(strIP, ipAddr)){
		printf("[ipAddr] = %02x:%02x:%02x:%02x\n", ipAddr[0], ipAddr[1], ipAddr[2], ipAddr[3]);
	}
parameter:
    *strIP : 输入的 ip地址字符串
    *binIP : 输出的 ip地址数组
Return:
	true 成功 false 失败
********************************************************************/
bool ipv4_str_to_bin(char *strIP, char *binIP)
{
    int i;
    char *s, *e;

    if ((binIP == NULL) || (strIP == NULL))
    {
        return false;
    }

    s = (char *) strIP;
    for (i = 0; i < 4; ++i)
    {
        binIP[i] = s ? strtoul(s, &e, 10) : 0;
        if (s)
           s = (*e) ? e + 1 : e;
    }
    return true;
}

/*********************************************************************
Function:
Description:
	把字符串形式的mac地址转换为数字形式
Example:
	char *strMac = "BC:8D:0A:7F:85:5E";
	char mac[6] = {0};
	if(mac_str_to_bin(strMac, mac)){
		printf("[mac] = %02x:%02x:%02x:%02x:%02x:%02x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
	}
parameter:
    *strMac : 输入的mac地址字符串
    *binMac : 输出的mac地址数组
Return:
	true 成功 false 失败
********************************************************************/
bool mac_str_to_bin(char *strMac, char *binMac)
{
    int i;
    char *s, *e;

    if ((binMac == NULL) || (strMac == NULL))
    {
        return false;
    }

    s = (char *) strMac;
    for (i = 0; i < 6; ++i)
    {
        binMac[i] = s ? strtoul(s, &e, 16) : 0;
        if (s)
           s = (*e) ? e + 1 : e;
    }
    return true;
}

/*********************************************************************
Function:
Description:
	比较为域名形式或为点分十进制的字符串形式的IP地址，
	忽略点分十进制前面或中间无效的0
Example:
	if(compare_IpAddr("192.168.001.110", "192.168.01.110")){
		printf("ip is sam\n");
	}else{
		printf("ip is not  sam\n");		
	}
parameter:
    *addr1 : 待比对Ip地址
    *addr2 : 待比对Ip地址
Return:
	true 相同 false 不同
********************************************************************/
bool compare_IpAddr(char *addr1, char *addr2)
{
	char tmpAddr1[64] = ".";
	char tmpAddr2[64] = ".";
	uint32_t i = 0, j = 0;
	bool ret = false;

	if ((addr1[0] < '0' || addr1[0] > '9') || (addr2[0] < '0' || addr2[0] > '9'))
	{
		if (0 == strcmp(addr1, addr2))
		{
			ret = true;
		}
	}
	else
	{
		for (j = 0, i = 0; i < strlen(addr1) + 1; i++)
		{
			if (addr1[i] == '0' && tmpAddr1[j] == '.')
				continue;
			tmpAddr1[++j] = addr1[i];
		}
		
		for (j = 0, i = 0; i < strlen(addr2) + 1; i++)
		{
			if (addr2[i] == '0' && tmpAddr2[j] == '.')
				continue;
			tmpAddr2[++j] = addr2[i];
		}
		
		if (0 == strcmp(tmpAddr1, tmpAddr2))
		{
			ret = true;
		}
	}
	
	return ret;
}


char* netAddrToStr(uint64_t netAddr)
{
	struct sockaddr_in addr = {0};
	addr.sin_addr.s_addr = netAddr;
	char *str;
	str = inet_ntoa(addr.sin_addr);
	return str;
}

uint64_t strToNetAddr(char *p_str)
{
	char str[36] = {0};
	strncpy(str, p_str, 36);
	struct in_addr addr = {0};
	if(inet_pton(AF_INET, str, (void *)&addr) != 1)
	{
		printf("fun:%s, line:%d, failed!\n", __FUNCTION__, __LINE__);
		return 0;
	}
	return addr.s_addr;
}

/*********************************************************************
Function:
Description:
	获取系统时间戳，通常用于性能测试
Example:
	uint64_t timeval_bf = get_timeval_us();
parameter:
    无
Return:
	系统时间戳，单位：微秒
********************************************************************/
uint64_t get_timeval_us()
{
    struct timeval tv;	
	gettimeofday(&tv, NULL);
	
	return ((uint64_t)tv.tv_sec * 1000000 + tv.tv_usec);
}

/*********************************************************************
Function:
Description:
	获取系统时间戳，通常用于性能测试
Example:
	uint64_t timeval_bf = get_timeval_ms();
parameter:
    无
Return:
	系统时间戳，单位：毫秒
********************************************************************/
uint64_t get_timeval_ms()
{
    struct timeval tv;	
	gettimeofday(&tv, NULL);
	
	return ((uint64_t)tv.tv_sec * 1000 + tv.tv_usec/1000);
}

/*********************************************************************
Function:
Description:
	获取系统时间戳，通常用于性能测试
Example:
	uint64_t timeval_bf = get_timeval_s();
parameter:
    无
Return:
	系统时间戳，单位：秒
********************************************************************/
uint64_t get_timeval_s()
{
    struct timeval tv;	
	gettimeofday(&tv, NULL);
	
	return (uint64_t)tv.tv_sec;
}

/*********************************************************************
Function:
Description:
	获取系统时间戳
Example:
	int timeStamp = get_time_stamp();
parameter:
	无
Return:
	系统当前时间戳
********************************************************************/
int get_time_stamp()
{
	time_t t;
	t = time(NULL);
 
	return time(&t);
}

/*********************************************************************
Function:
Description:
	把日期和时间按:年月日时分秒排列到参数中
Example:
	uint32_t curDate, curTime
	get_system_date_time(&curDate, &curTime);
parameter:
    *curDate:当前日期
    *curTime:当前时间
Return:
	无
********************************************************************/
void get_system_date_time(uint32_t *curDate, uint32_t *curTime)
{
    time_t timer;//time_t就是long int 类型
    struct tm *tblock;

    timer = time(NULL);
    tblock = localtime(&timer);

	*curDate = 10000 * (tblock->tm_year+1900) + 100 * (tblock->tm_mon + 1) + (tblock->tm_mday);
 	*curTime = 10000 * (tblock->tm_hour) + 100 * (tblock->tm_min) + (tblock->tm_sec);
}

/*********************************************************************
Function:
Description:
	设置系统时间，注意自动校时
Example:
	set_system_date_time(2021, 12, 22, 11, 14, 59);
parameter:
    year：年
     mon：月
     day：日
    hour：时
     min：分
    second：秒
Return:
	无
********************************************************************/
void set_system_date_time(int year, int mon, int day, int hour, int min, int second)
{
	time_t tStamp;
    struct timeval tv;

    struct tm t;
	
    year -= 1900;
    t.tm_year = year;
    t.tm_mon = mon-1;
    t.tm_mday = day;

    t.tm_hour = hour;
    t.tm_min = min;
    t.tm_sec = second;

	tStamp = mktime(&t);
    if(-1 == tStamp){
        perror("mktime");
    }else{
		tv.tv_sec = tStamp;
		tv.tv_usec = 0;
		settimeofday(&tv, NULL);
	}
}

/*********************************************************************
Function:
Description:
	以分离的模式创建一个线程,如果新线程与主线程共享变量，该线程必 须要确保
	它在运行期间， 线程体中使用的变量没有被主线程释放。否则会出问题。
Example:
    void *xxxThreadBody(void *arg)
	{
		pthread_exit(NULL);
	}
	
	pthread_t pId;
	int share_para;
	CreateNormalThread(xxxThreadBody, &share_para, &pId);
parameter:
    entry : 线程体执行函数
    *para : 传入线程体的参数，用作共享变量
    *pid  : 传入的pid为NULL，会直接退出整个进程
Return:
	 0：创建成功
	-1：创建失败
********************************************************************/
int CreateNormalThread(ThreadEntryPtrType entry, void *para, pthread_t *pid)
{
    pthread_t ThreadId;
    pthread_attr_t attr;

    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);//绑定
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);//分离
    if(pthread_create(&ThreadId, &attr, entry, para) == 0)//创建线程
    {
        pthread_attr_destroy(&attr);
        TRY_EVALUATE_POINTER(pid, ThreadId);

        return 0;
    }

    pthread_attr_destroy(&attr);

    return -1;
}





